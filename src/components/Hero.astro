<div id='canvas'></div>

<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #000;
  }

  #canvas {
    position: fixed;
    inset: 0;
  }
</style>

<script>
  import {
    Scene,
    FogExp2,
    PerspectiveCamera,
    WebGLRenderer,
    BufferGeometry,
    BufferAttribute,
    PointsMaterial,
    Points,
    AdditiveBlending,
    Clock
  } from 'three';

  const N = 15000,
    S = 0.15,
    R = 10;

  const scene = new Scene();
  scene.fog = new FogExp2(0x000000, 0.02);
  const camera = new PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
  camera.position.z = 30;
  const renderer = new WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(innerWidth, innerHeight);
  const amCanvas = document.getElementById('canvas') as HTMLCanvasElement;
  amCanvas.appendChild(renderer.domElement);
  const geo = new BufferGeometry();
  const pos = new Float32Array(N * 3);
  const tgt = new Float32Array(N * 3);
  const col = new Float32Array(N * 3);

  for (let i = 0; i < N; i++) {
    let j = i * 3;
    pos[j] = (Math.random() - 0.5) * 20;
    pos[j + 1] = (Math.random() - 0.5) * 20;
    pos[j + 2] = (Math.random() - 0.5) * 20;
    col[j] = 0;
    col[j + 1] = 1;
    col[j + 2] = 1;
    let a = (i / N) * Math.PI * 2;
    tgt[j] = Math.cos(a) * R;
    tgt[j + 1] = Math.sin(a) * R;
    tgt[j + 2] = (Math.random() - 0.5) * 4;
  }

  geo.setAttribute('position', new BufferAttribute(pos, 3));
  geo.setAttribute('color', new BufferAttribute(col, 3));

  const mat = new PointsMaterial({
    size: S,
    vertexColors: true,
    blending: AdditiveBlending,
    depthWrite: false,
    transparent: true,
    opacity: 0.85
  });
  const mesh = new Points(geo, mat);
  scene.add(mesh);
  let rx = 0,
    ry = 0,
    tx = 0,
    ty = 0;

  addEventListener('mousemove', e => {
    tx = (e.clientY / innerHeight - 0.5) * Math.PI * 2;
    ty = (e.clientX / innerWidth - 0.5) * Math.PI * 2;
  });

  const clock = new Clock();

  function loop() {
    requestAnimationFrame(loop);
    let p = geo.attributes.position.array;
    rx += (tx - rx) * 0.08;
    ry += (ty - ry) * 0.08;
    mesh.rotation.x = rx;
    mesh.rotation.y = ry;
    for (let i = 0; i < N; i++) {
      let j = i * 3;
      p[j] += (tgt[j] - p[j]) * 0.05;
      p[j + 1] += (tgt[j + 1] - p[j + 1]) * 0.05;
      p[j + 2] += (tgt[j + 2] - p[j + 2]) * 0.05;
    }
    geo.attributes.position.needsUpdate = true;
    renderer.render(scene, camera);
  }

  addEventListener('resize', () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  loop();
</script>
